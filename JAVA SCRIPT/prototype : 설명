https://medium.com/@bluesh55/javascript-prototype-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0-f8e67c286b67


Prototype을 사용하는 이유:
자바스크립트의 객체는 prototype 이라는 내부 property가 있다. 이는 객체, 심지어 함수(Prototype Object)까지 따라오는 속성으로 
객체에 존재하지 않는 속성에 접근을 시도하면 해당 객체의 property - Prototype 링크를 따라서 새 탐색 경로를 지정한다. 
모든 일반 객체의 최상위 프로토타입 링크는 내장 Object.prototype 이며, 이 장소에서도 결과를 찾아내지 못하면 탐색이 끝나게된다.
결론은, prototype은 모든 객체가 공유하는 최상위 프로토타입은 한번만 만들어지지만 
this 키워드를 이용하면 객체를 만들 때마다 메소드도 하나씩 만들어지기 때문에 메모리 낭비가 된다.


Example)

functionPerson(name, age) {
    this.name = name;
    this.age = age;
}
Person.prototype.show = function() {
               console.log('My name is ' + this.name + ", and I'm " + this.age + " years old.");
};
varperson3 = new Person("Steven", 30);
person3.show(); // My name is Steven, and I'm 30 years old.


: 원래 Person이라는 객체는 이름과 나이만 저장하고있었는데
하단에서 prototype으로 show라는 function을 붙여 확장을 함.
show는 메서드도 추가된 Person으로 재탄생하게된다.

function show(){ }  이것과  const show = function(){}은 같음.



2. 익명 함수

익명 함수는 자바스크립트의 함수를 선언하는 방법 중 하나입니다. 보통 우리가 함수를 만든다고 하면 아래와 같은 이미지를 떠올립니다:
console.log(add(1, 2));  // 3

function add(a, b) {
    return a + b;
}

console.log(add(3, 4)); // 7

이를 보통 기명 함수라고 부르고, 이 기명 함수인 add는 런타임 이전에 선언되므로 1번 라인의 명령도 정상적으로 실행된다.
익명 함수는 런타임에 동적으로 선언된다. 따라서 아래의 코드에서 1번 라인에서 TypeError를 반환한다.:

console.log(add(1, 2));  // TypeError: add is not a function

let add = function(a, b) {
    return a + b;
}

console.log(add(3, 4)); // 7
호이스팅에 따라 원하는 모양의 바운드를 만들어내지 못하는 경우가 나타나기 때문에, 
이런 상황을 방지하고자 익명 함수를 이용하고 또한 바로 logic를 만들어 넣을 수도있다.
